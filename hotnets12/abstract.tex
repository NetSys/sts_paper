Modern software-defined networking control platforms are highly complex distributed
systems. When control software behaves incorrectly, it is difficult
for developers to identify the exact events that caused the system to enter
an erroneous state. In this paper we tackle the problem of automatic
identification of fault-inducing input from logs of the system execution.

% ================ HotNets Take ================
%\colin{Is this an argument about how networks should be modeled? Or, how
%       network hardware should be built (what primitives they should
%       support)? Or, finally, is it just an argument about how we should
%       think of switches (re: the loose sense of the word ``model'')}
%
%Traditional network algorithms depend heavily
%on self-stabilization. You prove that the algorithm is correct, then you
%verify that your ASIC implements the algorithm correctly. When a change
%in the topology occurs (e.g. hardware failure, host migration, traffic
%shift), your system eventually self-stabilizes. [For other configuration
%changes, (e.g. the addition of a VLAN), manual configuration of each
%individual network device may be required.] But you could be fairly
%confident that your system would eventually converge!
%
%With software-defined
%networking, many protocols are no longer fully distributed.
%Todays SDN control platforms react to hardware failures, VM
%migrations, virtual address space allocation for new tenants, etc.
%Moreover, they are doing more complex things. Most tasks (e.g. VLAN
%addition) that used to be manually configured are now done automatically.
%The problem is, that the algorithms are not self-stabilizing! They are
%often stateful. And failover logic is really hard to get right!
%Insert quote from Urs Hoelzle.
%Moreover,
%its much easier to be loosy-goosy, since unlike hardware ASICs, you
%can just change it if you find out that its broken.
%
%We conclude that we need to think differently about how we treat
%network devices. \colin{(Why?)} In
%particular, we need to add support for vector clocks
%
%\colin{Can the Floodlight bug be solved with a self-stabilizing algorithm?}
%
%\colin{What other distributed systems primitives would we want out of network
%       devices? Transactions for consistency, vector clocks for casual
%       analysis + alternate consistency models, support for distributed locking?}
%
%\colin{TODO: read the NVP whitepaper. Floodlight's too, if its available}

% ================ PREVIOUS TAKE ================
%Distributed systems literature traditionally models the network as a
%black-box communication channel. \colin{This isn't quite what we want to say;
%we don't want the network to be included in the same model as the distributed
%application; we just want the network to be modeled by itself as a full-blown
%distributed system of its own}. We argue that switches and routers should be
%treated as first-class entities in the distributed system; in particular, we
%show that by

% ================ ORIGINAL ================
%The predominant technique for troubleshooting bugs in software-defined networks,
%log analysis, is tedious and error-prone. We argue that a more principled
%approach should be built around identifying inconsistencies between lower-level
%network configuration and higher-level policies dictated by control
%applications. Towards this end we present
%cross-layer correspondence checking, a mechanism to automatically detect and
%isolate policy violations due to bugs in the SDN platform. We observe,
%however, that in
%distributed systems such as SDN
%transient policy violations due to failures and delays are inevitable.
%Our \simulator{} framework augments correspondence checking by helping troubleshooters
%distinguish persistent from harmless ephemeral policy violations.
%We show that these mechanisms in combination can be used to quickly
%identify the root cause of difficult errors, including isolation breaches,
%faulty failover logic, and consistency problems between replicated
%controllers.
