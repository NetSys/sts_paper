Software-defined networking (SDN) proposes to simplify network management by
providing a simple logically-centralized API upon which network management
programs can be written. However, the software used to support this API is
anything but simple: the SDN control plane (consisting of the network
operating system and higher layers) is a complicated distributed system that
must react quickly and correctly to controller/switch/link failures, host migrations,
policy-configuration changes, and other events.
All complicated distributed systems are prone to bugs, and from our first-hand
familiarity with five open source controllers (Floodlight~\cite{floodlight}, NOX~\cite{nox},
POX~\cite{pox}, Pyretic~\cite{frenetic}, ONOS~\cite{ONOS}) and three major commercial
controllers, we can attest that SDN control software is no exception.
% All complicated distributed systems are prone to bugs and from our first-hand familiarity with several important open-source (NOX, POX, Floodlight, Frenetic, ONOS) and closed-source controllers (Google, VMware, BigSwitch), we can attest that SDN control platforms are no exception. 

%When faced with a bug, it is difficult to identify which events are triggering
%the bug; this act of ``troubleshooting'' (which precedes the act of debugging the
%underlying code) is extremely time-consuming,
When faced with symptoms of a network problem,
software developers must first identify which events are triggering
the apparent bug in the control software; this act of this act of ``troubleshooting'' (which precedes the act of debugging the
underlying code) is extremely time-consuming, as developers spend many hours poring
over multigigabyte execution traces.\footnote{A recent study suggested that software developers in general spend roughly half (49\% according to one
study~\cite{msoft_concurrency}) of their time troubleshooting, and spend
considerable time on bugs that are difficult to trigger (the same study found
that 70\% of the reported concurrency bugs take days to months to fix).} Bugs
are a fact of life; our aim is to make the troubleshooting process easier.

To that end, we have built a troubleshooting system for the SDN control plane.
Given a large execution trace, our tool attempts to automatically eliminate
trace events that are not causally related to the bug, producing a ``minimal
causal sequence'' (MCS) of triggering events. Once the original trace has
been reduced to an MCS (or an approximation thereof), the developer embarks
on the debugging process. Our claim is that the greatly reduced size of the
trace makes it easier for the developer to figure out which code path might be
responsible for the underlying bug, allowing them to focus their effort on
fixing the problematic code itself. After the bug has been fixed, the MCS
can serve as a test case to prevent regression,
and can help identify redundant bug reports where the MCSes are the same.

Our goal of minimizing test cases is in the spirit of
delta debugging~\cite{Zeller:1999:YMP:318773.318946}, but our
problem is harder in two dimensions: control software is distributed in space (\ie,
spread across many machines) and the input is distributed in time (\ie, the
input is not a single file, but a sequence of events).
We are therefore forced to cope with asynchrony and non-determinism while
we actively perturb causal relations (discounting deterministic replay
techniques), without making assumptions about the language
or instrumentation of the control software under test.
We are not aware of any other system that tackles these
challenges (though we discuss the vast amount of related work in \S\ref{sec:related_work}).

Our troubleshooting system, which we call {\projectname} for \projectmeaning,
consists of 21,000 lines of Python, and is designed to
integrate with existing QA test infrastructure (discussed in
\S\ref{sec:architecture}). We show that \projectname~is able
to minimize traces by up to \num{X\%} for \num{twelve}
previously known or synthetic bugs across a range of bug categories,
and demonstrate its viability by using \projectname~to find and
troubleshoot \num{six} previously unknown bugs involving
concurrent events during topology discovery, forgotten routing table entries
triggered by failures, and forgetten internal state triggered by unexpected input
sequences, found in four distinct
controllers (Floodlight, NOX, POX, Pyretic) written in three distinct
languages (Java, C++, Python).
