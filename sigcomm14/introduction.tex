Software-defined networking (SDN) proposes to simplify network management by
providing a simple logically-centralized API upon which network management
programs can be written. However, the software used to support this API is
anything but simple: the SDN control plane (consisting of the network
operating system and higher layers) is a complicated distributed system that
must react quickly and correctly to failures, host migrations,
policy-configuration changes and other events.
All complicated distributed systems are prone to bugs, and from our first-hand
familiarity with five open source controllers and three major commercial
controllers we can attest that SDN is no exception.
% All complicated distributed systems are prone to bugs and from our first-hand familiarity with several important open-source (NOX, POX, Floodlight, Frenetic, ONOS) and closed-source controllers (Google, VMware, BigSwitch), we can attest that SDN control platforms are no exception. 

%When faced with a bug, it is difficult to identify which events are triggering
%the bug; this act of ``troubleshooting'' (which precedes the act of debugging the
%underlying code) is extremely time-consuming,
When faced with symptoms of a network problem (\eg~a persistent loop)
that suggest the presence of a bug in the control plane software,
software developers need to identify which events are triggering
this apparent bug before they can begin to isolate and fix it.
This act of ``troubleshooting'' (which precedes the act of debugging the
underlying code) is highly time-consuming, as developers spend hours poring
over multigigabyte execution traces.\footnote{Software developers in general spend roughly half (49\% according to one
study~\cite{msoft_concurrency}) of their time troubleshooting and debugging, and spend
considerable time troubleshooting bugs that are difficult to trigger (the same study found
that 70\% of the reported concurrency bugs take days to months to fix).}
% Bugs are a fact of life;
Our aim is to reduce effort spent on troubleshooting SDN control software.

To that end, we have built a troubleshooting system that,
given an execution trace, attempts to automatically eliminate
trace events that are not causally related to the bug, producing a ``minimal
causal sequence'' (MCS) of triggering events. Once the original trace has
been reduced to an MCS (or an approximation thereof), the developer embarks
on the debugging process. We claim that the greatly reduced size of the
trace makes it easier for the developer to figure out which code path contains
the underlying bug, allowing them to focus their effort on
the task of fixing the problematic code itself. After the bug has been fixed, the MCS
can serve as a test case to prevent regression,
and can help identify redundant bug reports where the MCSes are the same.

Our goal of minimizing test cases is in the spirit of
delta debugging~\cite{Zeller:1999:YMP:318773.318946}, but our problem is
complicated by the distributed nature of SDN control software:
our test input is not a single file fed to a single point of execution, but an ongoing
sequence of events involving
multiple actors. Therefore we must carefully
control timings of events in the face of asynchrony and non-determinism
while we speculatively perturb the original execution,
without making assumptions about the language
or instrumentation of the control software. % under test.
As far as we know we are the first to minimize inputs to a distributed
system (discussed in \S\ref{sec:related_work}).

Our troubleshooting system, which we call {\projectname} ({\projectmeaning}),
consists of 21,000 lines of Python, and is designed so that organizations can
implement the technology within their existing QA test infrastructure (discussed in
\S\ref{sec:architecture}); over the last year we have worked with a
commercial SDN company to integrate \projectname~with their proprietary control
software. We evaluate the effectiveness of {\projectname} in
two ways. First and most significantly, we use {\projectname} to troubleshoot
seven previously unknown bugs---involving concurrent events during
bootstrapping, failure-induced blackholes, internal-state errors, and lock acquisition in a distributed database---that we found
by fuzz testing five controllers (Floodlight~\cite{floodlight}, NOX~\cite{nox},
POX~\cite{pox}, Pyretic~\cite{frenetic}, ONOS~\cite{ONOS})
written in three different languages (Java, C++, Python).
Second, we demonstrate the
boundaries of where \projectname~works well by
finding MCSes for previously known and synthetic bugs that span a range of bug
types. In our evaluation, we quantitatively show that \projectname~is able to
minimize traces by up to 98\% (of the new bugs), and we anecdotally found that reducing
traces to MCSes made it easy to understand the root causes of the bugs.
