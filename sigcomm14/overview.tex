In this section we review some of the key aspects of SDN systems, starting with the nature of the control plane and then the process of troubleshooting.

\paragraph{SDN Control Planes:}
Network operating systems, which are the key component of the SDN software infrastructure, involve controller software running on a replicated set of servers (each running a controller instance).  The replicas typically use a master election system and/or a consensus protocol to ensure consistency. A controller receives input events and statistics from switches (whether physical or virtual), configuration and policy changes via a management interface, and perhaps packets from the data plane (when using a reactive approach). In response to one or more of these events, the controller issues packet forwarding instructions to the switches.  All input and output events are asynchronous. These controller instances may communicate with each other over the network they manage, or use a separate dedicated network.  In either case, they may get partitioned.

\paragraph{Bugs, QA Testing, and Troubleshooting:}
The goal of a network control plane is to configure the switch forwarding entries so as to enforce one or more invariants, such as connectivity (there is a path between every endpoint pair), isolation and access control (\ie various limitations on connectivity), and virtualization (ensuring that packets are handled by physical switches in a manner consistent with what would happen in the specified virtual network). A bug is when such an invariant is violated. This bug could occur in the network management program (\ie the program itself improperly specified its goals), or it could occur within the SDN control plane. In this paper we focus on the latter problem (largely because the goal of SDN is to simplify the network management program and push all complexity to the control plane).{\bf this control plane, management program distinction is getting awkward....perhaps a diagram}

In commercial SDN development, software developers work with a team of QA engineers whose job it is to find bugs.  The QA engineers run test scenarios (\ie involving a sequence of external events such as failures, migrations, or policy changes) on large real or emulated networks.  If they detect an invariant violation, they hand the resulting trace to a developer for analysis. 

The space of possible bugs is enormous, and it is often extremely difficult to link the symptom of a bug (\eg a routing loop) to the sequence of events in the QA trace (which includes both the external events and monitoring data on the system itself). The act of {\em troubleshooting} involves identifying which set of external events is most directly responsible for triggering the bug; identifying these events helps the developer understand which code paths might hold the offending code. Currently, painstaking manual analysis of logs is the {\em de facto} method of troubleshooting distributed systems in practice.
{\em Debugging} is then the act of tracking down the error in the code itself, given a set of triggering inputs. The smaller the set of triggering inputs, the easier debugging will be. This is the goal of our system.

