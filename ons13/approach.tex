To use \simulator, software developers first employ our network simulator to generate
random or hand-chosen inputs
to the (unmodified) control software under test. Throughout the simulation,
developers can interactively examine the state of the network
and employ verification tools such as header space analysis~\cite{hsa} to check
for invalid configurations. Driving the
execution of the system in this way allows us to record a
totally-ordered log of the events to be replayed later.

After recording a trace that triggers a bug (\ie~results in an invalid configuration), our goal is to identify a minimal
subsequence of the trace that is sufficient for re-triggering the bug. We
call this output a {\em minimal causal sequence} (MCS).
At the least, minimal causal sequences eliminate distracting events during
replay and reduce the runtime of test cases.
More importantly,
minimal causal sequences give developers intuition about what code path is throwing
the network into an invalid configuration.

Delta debugging~\cite{Zeller:1999:YMP:318773.318946}, a technique from the
software engineering community, gets us part of the way
to our goal: given a single input (\eg~an HTML page)
for a non-distributed program (\eg~Firefox), it performs a divide-and-conquer
search, repeatedly running the program on subsets of the input
until it finds a minimal subset (\eg~a single tag) that is sufficient
for triggering a known bug.

However, delta debugging assumes a one-time input to a single program;
executions of software-defined networks involve ongoing series of inputs to a distributed system.
In such an environment, pruning parts of the input trace can cause the execution to
subtly change (\eg~the sequence numbers of packets may differ), and some
state changes that occurred in the original run may not occur. Our main
challenge is to maintain causal relationships while replaying inputs,
despite such divergences in the execution.

Our first observation is that many internal events are {\em functionally
equivalent}, in the sense that they
have the same effect on the state of the system with respect to triggering the
correctness violation (despite syntactic differences). For example, flow
modification messages may cause switches to make the same change to their forwarding behavior
even if the transaction identifier of the messages differ. We leverage this observation by defining
masks over semantically extraneous fields of
internal events, which allow us to reason about slight differences across
runs.

Syntactic differences are not the
only possible change induced by pruning though: internal state changes
(\eg~message receipts, timers going off, or internal state
changes) from the original
run also cease to appear.
Without tracking internal state changes, causal relationships may be violated during replay,
meaning that the bug may not be successfully reproduced;
consider for example that if a controller's garbage collector happens to run
while we replay inputs, it may delay an internal state transition until
after the simulator injects a dependent input.
Yet without knowing \apriori~which internal events are going to occur after
pruning, it is unclear which internal events to wait for. Our approach is to time out and proceed
if expected internal do not occur within a certain time \textepsilon.

