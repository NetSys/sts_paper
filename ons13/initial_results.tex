We have applied \simulator~to three open source SDN control platforms:
POX, NOX, and Floodlight. Over a span
of roughly five days of
investigation we found a total of five bugs. \Simulator~reduced the
size of the input trace to 37\% of its original size in
the worst case and 2\% of its original size in the best case.
We show the overall results of our case studies
in Table~\ref{tab:case_studies}.

\begin{table*}
\centering
\begin{tabular}{l|l|l|l|l}
Bug Name & Topology & Runtime & Total Inputs & MCS Size \\
\hline
POX list removal & 2 switch mesh & 141.0s & 76 (69) & 2 (2) \\
% Original: config/eugene_epsilon_replay.py
% MCS: config/eugene_epsilon_mcs.py
POX in-flight blackhole & 2 switch mesh & 2855.5s & 68 (26) & 25 (11) \\
% Original: 7ba95ed82ca4e32f12ab511d9c4301dbac2c59d5
% MCS: 399cf861db87a65e600283d9ae7760400c4676e2
POX migration blackhole & 4 switch mesh & 1796.0s & 117 (29) & 3 (2) \\
% fuzz_pox_4mesh_blackhole on pox_blackhole branch
NOX discovery loop & 4 switch mesh & 20237.6s & 358 (150) & 58 (18) \\
% Original: ce547fc1df3bde279b6f3dd589c909663e295f1e
% MCS: 5f49e791b0c1a611454cf0930f54aa609dd635d3
Floodlight loop & 3 switch mesh & analysis pending & analysis pending & analysis pending\\
% Andi
\end{tabular}
\caption{Overview of bugs found and MCS results. Totals shown in parentheses
exlude dataplane permit events.}
\label{tab:case_studies}
\end{table*}

We briefly describe one bug in POX's routing module to illustrate the value of minimal causal sets.
We noticed that our tool reported a persistent blackhole between two hosts A
and B while POX was bootstrapping its
discovery of link and host locations. There were 68 inputs in the initial trace, and \simulator~returned a 25 input
MCS. With the MCS in hand we took out paper and pencil to decipher what had
transpired.

We found that the crucial triggering events were two
{\em in-flight} packets (set in motion by prior traffic injection events),
concurrent with POX's discovery of a switch-switch link.
More specifically, we saw that directly after POX discovered the link connecting the two
switches, the first in-flight packet from host A arrived at
B's attached switch without a prior PacketIn from A's attached switch.
This was POX's first mistake: although it correctly realized that hosts cannot
be attached to the newly discovered switch-switch link, the code did not correctly handle in-flight packets
concurrent with the discovery of the link. As a result, it incorrectly learned A's location at
the switch-switch link.

The next event we observed was another in-flight packet arriving from B to
A. POX
proceeded to install a path for this new B$\rightarrow$A flow, but the
path itself contained a loop! The default behavior of
OpenFlow switches is to ignore route entries (with wildcarded
IN\_PORTs) that forward out the
same port the packets arrived on. This is where we started observing the blackhole:
now whenever B sent traffic to A, it would be dropped until
the faulty routing entry would eventually expire 30 seconds later.
Upon further examination, we found that the programmer had neglected to return out
of a nested conditional, causing a B$\rightarrow$A flow entry to be
installed at one too many switches.

These fine-grained race conditions would have been difficult to reproduce
in Mininet~\cite{handigol2012reproducible} or real hardware. With our
network simulator's capacity to arbitrarily delay messages, the bug was easily uncovered. And with
an MCS in hand, it was straightforward to identify the root cause from an
otherwise complicated trace.
We have sent the minimized, replayable bug trace to the lead
developer of POX, and await his response.
