In this section we present two mechanisms based on the principle of ``seeing
through the noise''. Correspondence checking allows troubleshooters to isolate
the cause of inconsistencies to a particular layer. Simulated replay analysis 
allows troubleshooters to isolate relevent events throughout the system
execution. We provide the details of these techniques below. 

\subsection{Correspondence Checking}

The sole task of the application layer is to specify network
policies. The platform is left to translate these high-level policies
into changes in the physical network.

Platform correctness can therefore be expressed as a simple invariant:
the state of the application layer should correspond to the state of the
physical network. We check this invariant by applying the virtual packet notation pioneered
in headerspace analysis~\cite{hsa}. 

Formally, each layer of the SDN stack can be represented as a graph,
$G = (V, E)$. Packets are series of bits, $h \in \{0,1\}^L = H$,
where $L$ is the maximum number of bits in the header. Upon receiving a packet,
forwarding elements apply a transformation function \footnote{We assume unicast forwarding for clarity}
\footnote{Note that forwarding elements may rewrite fields of a packet header
before passing it along. Forwarding elements may also drop packets.} \\
$T: (H \times E) \rightarrow (H \times E_{\emptyset})$

We use $`\Psi`$ to denote the collection of all transfer functions present in
the network at a particular point in time. In this model, network traversal is simply a composition of transformation
functions. For example, if a header $h$ enters the network through edge
$e$, its state after $k$ hops will be:
\begin{align*}
\Phi^k(h,e) = \Psi(\Psi(\dots \Psi(h,e)\dots))
\end{align*}

The externally visible behavior of the network can be expressed as a the
transitive closure of $\Phi$:
\begin{align*}
\Omega: (H \times E_{access}) \rightarrow (H \times E_{\emptyset}) \\
\Omega(h,e) = \Phi^{\infty}(h,e)
\end{align*}
Here, $E_{access}$ respresents access links adjacent to end-hosts.

In SDN, it should always be the case that 
$\Omega^{view} \sim \Omega^{physical}$. Formally:
\begin{align*}
\forall_{h} \forall_{e \in E_{access}^{view}} \Omega^{view}(h,e) =
\Omega^{physical}(encap(h),e) 
\end{align*}
where $encap$ is a function from packets in $G^{view}$ to packets in
$G^{physical}$. Note that the mapping between $G^{view}$ and $G^{physical}$ is not
necessarily one-to-one. Hosts are represented at all layers however, hence
$E_{access}^{view} \sim E_{access}^{physical}$ is a bijection.

To check correspondence in SDN, we begin by taking a causally consistent
snapshot~\cite{Chandy:1985:DSD:214451.214456} of the physical network. The routing
tables of forwarding elements can then be translated into transformation functions.
Finally, we feed a symbolic packet $x^L$ to each access link of the network in
order to generate
a propagation graph representing all possible paths taken by a packet injected
at the access link. The leaves of the propogation graph represent $\Omega$. We
can verify correspodence in SDN by generating propogation graphs for all SDN layers,
and comparing the leaves.

\begin{itemize}
\item This tells you the general cause of the of the error (not detailed
debugging info)
\item If you're just looking for who to blame, all you need is correspondence
checking!
\item For SDN developers though, need a bit more. Correspondence checking only tells you behavior at one point in time.
Also, there will almost always be inconsitencies, due to delays, failures,
\etc.
\item \colin{new subsection here?} need a record / replay / simulate mechanism to capture the time axis.
    \begin{itemize}
    \item Since proactive, just need snapshots of production routing tables,
    link state events, and controller state events.
    \item Feed ``before-bug'' or ``after-bug'' state into simulated model of production network. 
    \item simulator enables deterministic ``time-travel'' and nice debugging
    loop.
        \begin{itemize}
        \item We tell you the component where the problem manifests
        \item you put in more printfs
        \item If you want, induce failures, delays, drops, etc.
        \item you play forward in time, to help you find which events matter
        \item rinse and repeat until bug is found.
        \end{itemize}
    \item \colin{Mention that model checking could help here?}
    \end{itemize}
\end{itemize}

