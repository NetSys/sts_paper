In this section we present two mechanisms to facilitate the troubleshooting
process. Correspondence checking allows troubleshooters to isolate
the cause of inconsistencies to a particular layer. \Simulator{}
allows troubleshooters to isolate relevant events throughout the system
execution. We provide the details of these techniques below. 

\subsection{Correspondence Checking}

The sole task of the application layer is to specify network
policies. The platform translates these high-level policies
into changes in the physical network.

Platform correctness can be expressed as a simple invariant:
the state of the application layer should correspond to the state of the
physical network. We check this invariant by applying the virtual packet
algebra pioneered in headerspace analysis~\cite{hsa}. 

Formally, each layer of the SDN stack can be represented as a graph,
$G = (V, E)$. Packets are series of bits, $h \in \{0,1\}^L = H$,
where $L$ is the maximum number of bits in the header. Upon receiving a packet,
forwarding elements apply a transformation function, potentially modifying
packets before forwarding them on\footnote{We assume unicast forwarding for
clarity}:
\begin{align*}
T: (H \times E) \rightarrow (H \times E_{\emptyset})
\end{align*}

We use $`\Psi`$ to denote the collection of all transfer functions present in
the network at a particular point in time. In this model, network traversal is simply a composition of transformation
functions. For example, if a header $h$ enters the network through edge
$e$, its state after $k$ hops will be:
\begin{align*}
\Phi^k(h,e) = \Psi(\Psi(\dots \Psi(h,e)\dots))
\end{align*}

The externally visible behavior of the network can be expressed as the
transitive closure of $\Phi$:
\begin{align*}
\Omega: (H \times E_{access}) \rightarrow (H \times E_{\emptyset}) \\
\Omega(h,e) = \Phi^{\infty}(h,e)
\end{align*}
Here, $E_{access}$ represents access links adjacent to end-hosts.

In SDN, it should always be the case that 
$\Omega^{view} \sim \Omega^{physical}$. Informally, this means that
any packet injected at an access link in $G^{virtual}$ should arrive at
the same final location as the corresponding (encapsulated) packet injected at the
corresponding access link in $G^{physical}$. Note that hosts are represented
in all graphs, although though there may not be a one-to-one mapping between the
internal vertices of $G^{virtual}$ and $G^{physical}$.

To check correspondence in SDN, we begin by taking a causally consistent
snapshot~\cite{Chandy:1985:DSD:214451.214456} of the physical network. The routing
tables of forwarding elements can then be translated into transformation functions.
Finally, we feed a symbolic packet $x^L$ to each access link of the
network~\footnote{The rules for process wildcard bits $x^n$ are defined in
the HSA paper~\cite{hsa}}. The end result is a propagation graph representing all possible paths taken by a packet injected
at the access link.

The leaves of the propagation graph represent $\Omega$. We
verify correspondence in SDN by generating propagation graphs for all SDN layers,
and comparing the leaves.

\subsection{\SIMULATOR{}}

For many use-cases, isolating an error to a particular layer suffices.
For example, a network operator might verify that inconsistencies manifest in
the platform but not her own policy specification, and thereby hand off
troubleshooting responsibility to a maintainer of the platform. 

To isolate and fix the root cause of a problem however, troubleshooters will often
need more information. In particular, correspondence checking only enumerates
inconsistencies present in the network at a particular point in time;
troubleshooters need the ability to explore the execution of the system over
time. Our approach is to record the state of the production network and replay 
execution in a simulated model of the system.

Even in small networks,
the number of low-level events captured by
log-statements can be overwhelming. The main utility of \simulator is that
troubleshooters can easily differentiate pertinent events from
irrelevant diagnostic information. At any point in time, the troubleshooter
can run correspondence checking to enumerate all inconsistencies in the
network. She can then iteratively prune out extraneous external events until
she is focused in on only the relevant traces. She can further differentiate
ephemeral from persistent inconsistencies by playing the execution of the
system forward in time, tracking the life cycle of inconsistencies.

Modeling the execution of the system in a straightforward debugging loop; once the 
relevant traces and system components have been isolated, troubleshooters can
restart the execution, add log statements, and iteratively repeat until the
relevant code block has been fixed. Modeling the system additionally
yields complete control of the timing, ordering and production of events.
For example, troubleshooters can proactively induce failures or packet drops
to reproduce the failure-condition observed in practice.

\colin{Out of place?} Note that for a proactive
network, only periodic snapshots of routing tables, link state events, and
control server failure events are needed for high-fidelity replay.

\colin{Mention that model checking could help here?}

