We have applied \projectname~to the routing applications\footnote{At the time
we conducted these experiments, routing was among the most complex
SDN applications publicly available. We are currently investigating
distributed controllers with more complex applications such as network virtualization,
which have recently become publicly available. We believe bugs involving
distribution are particularly amenable to techniques such as ours.} of three open
source SDN control platforms:
POX~\cite{pox}, NOX~\cite{nox}, and Floodlight~\cite{bigswitch}. We describe
bugs we found in each of these controllers to illustrate
how the minimized traces our technique produced were valuable in
understanding the bugs' root causes.

\subsection{POX In-Flight Blackhole}
After roughly 20 runs of randomly generated inputs,
we noticed that \projectname~reported a persistent blackhole while
POX was bootstrapping its
discovery of link and host locations in a small 2-switch, 2-host network.
There were $29$ inputs in the initial trace, and \projectname~returned an $11$ input
MCS.

We provided the MCS to the lead developer of POX. Primarily using the
console output, we were able to trace through the code and identify the problem
within 7 minutes, and were able to find a fix for the race condition within 40
minutes. By matching the console output with the code, he found that the crucial
triggering events were two
in-flight packets (set in motion by prior traffic injection events):
POX first incorrectly learned a host location as a result of the first in-flight
packet showing up immediately after POX discovered that that port belonged to
a switch-switch link -- apparently the code had not accounted for the
possibility of in-flight packets directly following link discovery -- and
then as a result the
second in-flight packet
POX failed to return out of a nested conditional that would have
otherwise prevented the blackholed routing entries from being installed.

Although the initial trace was fairly small to begin with, knowing that every
input in the MCS was necessary for triggering the race condition allowed us to
avoid the
possibility of being mislead by extraneous diagnostic information while
tracing through the many potentially faulty code paths.

\subsection{NOX Discovery Loop}

We initially tested NOX on a two node topology, but did not find any immediate
problems. We then extended the topology to a four-node mesh, and discovered a
routing loop between two switches (involving routes for two hosts) within
roughly $20$ runs of randomly generated inputs.

Our initial input size was $150$ inputs, a minute's worth of execution.
Our system returned an $18$ input MCS.

\tbd{}

\subsection{Floodlight Forwarding Loop}

We used the STS Fuzzer on the current open-source version of floodlight with the
'Forwarding' application. In about 30 minutes, the fuzzer identified a 377-event
sequence (117 input) that caused a persistent 3-node forwarding loop. \simulator{
} reduced the sequence to 13 input events in 8.5 hours and 324 replays.

For debugging, we repeatedly replayed the 13 event MCS, while
successively adding instrumentation and increasing the log level. After 
~15 replay attempts, we diagnosed that the problem was caused by interference of
end-host traffic with ongoing link discovery packets: In our experiment, floodlight
had not discovered an inter-switch link due to dropped LLDP packets, causing an
end-host to flap between perceived attachment points.

While this behavior cannot strictly be considered a bug in the floodlight
code-base, the case-study nevertheless highlights the benefit of \simulator{}
over traditional fuzzing techniques: By leveraging repeated replays of a
significantly reduced MCS, we were able to diagnose the root cause -- a complex
interaction between the LinkDiscovery, Forwarding, and DeviceManager
modules -- with limited experimentation.
