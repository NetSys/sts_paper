We represent the forwarding state of the network
at a particular time as a configuration $c$, which contains all the forwarding
entries in the network
as well as the liveness of the various network elements.
The network control plane is a system that takes a sequence of
external network events $E$ (such as link failures) as input,
and produces a sequence of network configurations
$C = c_1,c_2,\dots,c_n$.

An invariant is a predicate $P$ over forwarding state (a safety
condition, such a having no loops or blackholes). We say that a configuration
$c$ violates an invariant if $P(c)$ does not
hold, also denoted as $\overline{P}(c)$.

In our formalism a log $L$ of a system execution\footnote{In
\S\ref{sec:systems_challenges} we how logs can be obtained.} is a triplet of external events $E_L$,
timing information $T_L$ of the external events, and a sequence of forwarding
configurations $C_L$.
A replay of log $L$ involves replaying the external events along with a
particular timing $T$,
which need not be identical to the original timings captured in the log.
We denote a replay attempt by $replay(E_L,T)$.
The output of $replay$ is a sequence of forwarding state configurations
$C_R = \hat{c}_1,\hat{c}_2,\dots,\hat{c}_n$. In the ideal case $replay(E_L,T_L)$ reproduces the same
sequence of network configurations as occurred in the original run
(\ie~$\forall_i. c_i = \hat{c}_i$), but as we discuss later in the paper there are reasons why
this does not always hold.

If the original log $(E_L, T_L, C_L)$ exhibited a violation
(\ie~$\exists_{c_i \in C_L}. \overline{P}(c_i)$,
then we say its replay reproduces that invariant violation if
$\exists_{\hat{c}_i \in replay(E_L,T)}. \overline{P}(\hat{c}_i)$.

\noindent~{\em Definition}: a minimal causal sequence (MCS) is a subsequence $E_M$ of $E_L$ and a timing $T_M$ such
that $replay(E_M,T_M)$ reproduces the invariant violation, but for all proper
subsets $E_N$ of $E_M$
there is no timing $T$ s.t. $replay(E_N,T)$ reproduces the violation.

\subsection{Assumptions}

\colin{These aren't really assumptions, they're really facts that serve as
motivation. I might cut this once the introduction is written.}

We make several assumptions in motivating our problem.

Assumption 1: naturally occurring logs $E_L$ are large.

Assumption 2: the MCS of most natural logs resulting in violations are much smaller than the original log.  That is, bugs are causally sparse.

Troubleshooting is the act of finding small logs that reproduce problems, so that developers can debug.
