\subsection{Definitions}

We represent the forwarding state of the network
at a particular time as a configuration $c$ (this state contains all the forwarding entries, as well as the liveness of the various network elements).
The network control plane is a system that takes a sequence of
external network events $E$ (such as link failures) that occur at times $T$
as input and produces a sequence of network configurations
$C = c_1,c_2,\dots,c_n$.

An invariant is a predicate $P$ over forwarding state (a safety
condition, such a having no loops or blackholes). We say that a configuration
$c$ violates an invariant if $P(c)$ does not
hold, also denoted as $\overline{P}(c)$.

One can obtain logs of control plane executions by running integration or fuzz
tests. In our formalism a log $L$ is a triplet of external events $E_L$,
timing information $T_L$ of the external events, and the forwarding states
$C_L$. A replay of log $L$ involves replaying the external events along with a particular timing $T$
which need not be identical to the original timings in the captured log.
We denote this by $replay(E_L,T)$.
The output of $replay$ is a sequence of forwarding state configurations
$C_R = \hat{c}_1,\hat{c}_2,\dots,\hat{c}_n$. In the ideal case $replay(E_L,T_L)$ reproduces the same
sequence of network configurations as occurred in the original run
(\ie~$\forall_i. c_i = \hat{c}_i$), but as we discuss later in the paper there are reasons why
this does not always hold.

If the original log $(E_L, T_L, C_L)$ exhibited a violation
(\ie~$\exists_{c_i \in C_L}. \overline{P}(c_i)$,
then we say its replay reproduces that invariant violation if
$\exists_{\hat{c}_i \in replay(E,T)}. \overline{P}(\hat{c}_i)$.

\noindent~{\em Definition}: an MCS is a subsequence $E_M$ of $E_L$ and a timing $T_M$ such
that $replay(E_M,T_M)$ reproduces the invariant violation, but for all proper
subsets $E_N$ of $E_M$
there is no timing $T$ s.t. $replay(E_N,T)$ reproduces the violation.
\\

\subsection{Assumptions}

Assumption 1: naturally occurring  logs $E_L$ are large.

Assumption 2: the MCS of most natural logs resulting in violations are much smaller than the original log.  That is, bugs are causally sparse.

Troubleshooting is the act of finding small logs that reproduce problems, so that developers can debug.

\subsection{Technical Challenge: Approximating MCSes}

\begin{outline}
\1 Dumb approach: explore all timings $T$ for each subset of $E_L$.

\1 Slightly smarter approach:
  \2 use delta debugging
  \2 but that changes history, and potentially causality
  \2 so define equivalence
  \2 and time out on missing internal
  \2 and let new events through
  \2 this leaves exactly one set of timings $T$ to look at, that in our
  experience very reliably reproduces the bugs while still minimizing.

\1 There are some practical challenges involved in implementing this approach in
practice, including:
   \2 the need for a mechanism, to replay these traces.
   \2 the need for visibility into internal events.
   \2 the need to cope with non-determinism outside the control of the
   replay mechanism.
   \2 the need to cope with new / unexpected internal events

\1 In the next section we outline our solution to these difficulties.
\end{outline}
