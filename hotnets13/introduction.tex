Modern SDN control platforms are highly complex,
distributing state between replicated
servers~\cite{floodlight},
providing isolation and resource arbitration between multiple
tenants~\cite{Casado:2010:VNF:1921151.1921162}, and
globally optimizing network utilization~\cite{urs}.
As with any highly complex codebase, software bugs are an unpleasant but everpresent fact-of-life. In fact, based on anecdotal evidence from colleagues in the industry, it seems clear that
developers of software-defined networks spend much of their time
troubleshooting bugs. This should be no surprise, since software developers in
general spend roughly half (49\% according to one
study~\cite{msoft_concurrency}) of their time troubleshooting, and spend
considerable time on bugs that are difficult to trigger
(the same study found that 70\% of the reported concurrency bugs
take days to months to fix).

The troubleshooting process, which starts by analyzing long logs gathered from either operational monitoring or QA testing, is hindered by the large number of hardware failures,
policy changes, host migrations, and other inputs to SDN control software.
As one data point, Microsoft Research
reports 8.5 network error events per minute per
datacenter~\cite{Greenberg:2009:VSF:1592568.1592576}.
Troubleshooters find little immediate use from logs containing many inputs
prior to a fault,
since they are forced to manually filter extraneous inputs
before they can start fruitfully investigating the root cause.
It is no surprise that when asked to describe their
ideal tool, most network admins said ``automated troubleshooting''~\cite{Zeng:Survey}.

%And despite the prevalence of failures, maintaining uptime is of critical importance; according to one
%survey, ``meeting customer expectations about reliability'' is the second highest
%priority for networking professionals~\cite{market_report}.
% Software bugs cost $59 billion in 2002: bit.ly/V2Z7Al

Before continuing, we should clarify what we mean by `troubleshooting' and `bugs' in the SDN context.
SDN networks are designed to support high-level policies, such as inter-tenant
isolation (\ie~ACL enforcement). A bug, in this context, creates situations
where the network violates one or more of these high-level policies; that is, even though the control plane
has been told to implement a particular policy, the resulting configuration (\ie~flow entries in the switches)
does not do so properly. We call this an {\em invalid} configuration.
We presume that the control plane functions properly in most circumstances, so
that these policy violations are rare and are symptoms of an underlying software bug (such violations could also result from a hardware failure, or a policy misconfiguration, but here we focus on those cases where the violation is due to a software bug).

Bugs may be triggered by uncommon sequences of inputs, such as a simultaneous link failure or controller reboot.
The act of troubleshooting involves identifying which set of inputs is more directly responsible for triggering the bug.
Debugging is then the act of tracking down the error in the code itself, given a
set of triggering inputs.
The smaller the set of triggering inputs, the easier debugging will be.

Our focus here is on troubleshooting. When we observe an invalid
configuration,
which is prima facie evidence for a bug, our goal is
to automatically filter out inputs to the SDN software (\eg~link failures)
that are not relevant to triggering the bug, leaving a small sequence of inputs
that is directly responsible.
This would go a long way towards achieving ``automated troubleshooting.'' Our approach is very similar in spirit to delta debugging~\cite{Zeller:1999:YMP:318773.318946}, but involves a very different set of technical challenges since networks are distributed asynchronous systems.

In the next section we formally define the problem of isolating fault-inducing
inputs to distributed systems. We then outline our approach in
\S\ref{sec:approach}, and the
system we built to realize our approach in \S\ref{sec:systems_challenges}.
We end by describing preliminary case studies that illustrate how minimized
input logs help software developers fix bugs.
