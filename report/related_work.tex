CLINT extends a growing literature on debugging and software engineering tools for Software-Defined Networks.
    
Some efforts have focused on debugging control applications; however, none do pervasive,
cross-layer analysis to address bugs in the network operating system itself. 
Canini et al.~\cite{canini} develop symbolic execution techniques to identify
common cases where application developer's assumptions about the behavior of
their application may not hold. This work is complementary to ours in
that we focus on the bugs in the SDN stack itself, not control applications.
In future work, we plan to leverage symbolic execution in our
input generator to more efficiently explore the configuration space
of control applications.

Focusing on the physical network, Anteater~\cite{anteater} is a static checker that
detects invariant violations in the configuration of switches and routers.
Anteater takes as input a snapshot of the FIB of each network device, as well as
additional control information such as SNMP updates or VLAN configuration. It then
generates a set of constraint functions and feeds them through a SAT solver to verify whether
any possible traffic exists that would break an invariant (such as those we describe in \S\ref{sec:approach}).
 We leverage
Anteater as the invariant checker component of our system.
Nonetheless, Anteater only detects bugs which manifest entirely within the physical network;  
it cannot detect errors that manifest across the layers of the SDN stack, such as mismatches
between the control server's view of the network state and the actual state of the
physical FIBs. Further, even when Anteater detects an error within the physical network, it cannot pinpoint
which component of the SDN stack is responsible for the bug, as it does not perform cross-layer
analysis. Finally, as we discuss in \S\ref{sec:approach} (and resolve with our input generator), 
Anteater detects bugs in a static configuration
of the physical network, and cannot detect bugs that might arise under a different configuration or with different
inputs to the same network controller.

Also focusing on the physical network, OFRewind~\cite{ofrewind} develops record and replay techniques
for OpenFlow networks. The replay
mechanism of OFRewind allows network operators to step through sequences of
events that led up to an error condition. OFRewind is a `live' version of our
simulator's input generator. We plan to take a similar approach when we apply
our debugger to live deployments.  \justine{TODO: flowchecker}

Another line of work aims to prevent bugs from being introduced in the first
place. Frenetic~\cite{frenetic} presents a language-based approach to building
robust SDN applications. By providing a specialized programming model, Frenetic helps developers avoid writing common classes of
bugs, such `composition errors' where installed flow entries override eachother.
Reitblatt et al.~\cite{consistentupdates} develop a technique for ensuring
consistent routing updates, such that all switches in the network either route
a given packet under the new configuration, or under the old configuration,
but not both. This mechanism would resolve common causes for routing consistency 
invariant violations.

More broadly, projects such as Pip~\cite{pip} and d$^3$s~\cite{d3s} develop
techniques for debugging general distributed systems. \colin{TODO: skim these
papers}\justine{later! We need no more description than this for now}. 
We demonstrate with CLINT that by constraining the scope of the problem,
we can provide more comprehensive tools for a more limited domain. \colin{At
this point the tools aren't more comprehensive :P}\justine{SHHHH SECRET ERIC WILL NEVER okay yeah he's totally gonna catch us.}

% If we manage to run multiple applications by Monday, we should cite papers
% on consistency and cross-layer debugging:

%X-Trace~\cite{xtrace}

% Vector Clocks

% Onix

% Virtualization definitely won't happen by Monday. But, papers include
% Martin's presto '10 paper 'Virtualizaing the Network Forwarding Plane'
